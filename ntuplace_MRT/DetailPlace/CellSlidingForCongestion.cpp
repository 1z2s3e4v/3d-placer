#include "CellSlidingForCongestion.h"
#include "placedb.h"
#include <climits>

using namespace std;
using namespace Jin;

CCellSlidingRow::CCellSlidingRow( 
	const double& bottom, 
	const double& height,
	const double& left,
	const double& right ) :
    m_bottom( bottom ),
    m_height( height )
{
    m_interval.reserve(2);
    m_interval.push_back( left );
    m_interval.push_back( right );
}

CCellSlidingRow::~CCellSlidingRow(void)
{
}

CCellSlidingForCongestion::CCellSlidingForCongestion( CPlaceDB& placedb ) :
    m_placedb( placedb )
{
    //m_hdim = gridNum;
    m_step = m_placedb.m_sites.front().m_step;
#if 0
    //test code
    fprintf( stdout, "step: %f\n", m_step );
    //@test code
#endif
    
    m_rows.reserve( m_placedb.m_sites.size() );
    
    for( unsigned int i = 0 ; i < m_placedb.m_sites.size() ; i++ )
    {
	const CSiteRow& siteRow = m_placedb.m_sites[i];
	//if( m_placedb.m_sites[i].m_interval.size() != 2 )
	//{
	//    fprintf( stderr, "Warning: CCellSlidingForCongestion cannot handle m_placedb.m_sites[%d].m_interval.size()=%d\n",
	//	    i, m_placedb.m_sites[i].m_interval.size() );
	//}

	for( unsigned int iInt = 0 ; iInt < siteRow.m_interval.size() ; iInt = iInt+2 )
	{
	    m_rows.push_back( CCellSlidingRow( 
			siteRow.m_bottom, 
			siteRow.m_height,
			siteRow.m_interval[ iInt ],
			siteRow.m_interval[ iInt+1 ] ) ); 
	}
    }

    //Push module ids into m_module_queue of each row
    //list< pair<int,double> > module_id_list;
    list< ModuleSortElement > module_id_list;
    for( unsigned int iMod = 0 ; iMod < m_placedb.m_modules.size() ; iMod++ )
    {
	const Module& curModule = m_placedb.m_modules[iMod];
	
	if( curModule.m_isFixed || curModule.m_height > m_placedb.m_rowHeight )
	{
	    continue;
	}

	module_id_list.push_back( ModuleSortElement( iMod, curModule.m_x, curModule.m_y ) );
    }

    module_id_list.sort( ModuleXCoorComparator() );
    //Assume sites are vertically continuous and have uniform site height
    int rowIndex = 0;
    //double site_bottom = m_rows.front().m_bottom;
    //double site_height = m_rows.front().m_height;
    
    for( list< ModuleSortElement >::iterator ite = module_id_list.begin() ; 
	    ite != module_id_list.end() ; ite++ )
    {
	const int curModuleId = ite->m_module_id;
	const double curModuleX = ite->m_x;
	const double curModuleY = ite->m_y;

	//int rowIndex = static_cast<int>( ( curModuleY - site_bottom ) / site_height );

	while( m_rows[ rowIndex ].m_bottom != curModuleY || 
		!( curModuleX >= m_rows[ rowIndex ].m_interval.front() &&
		    curModuleX <= m_rows[ rowIndex ].m_interval.back() ) )
	{
	    rowIndex++;

	    //Do not find a corresponding row
	    if( rowIndex >= static_cast<int>( m_rows.size() ) )
	    {
		fprintf( stderr, "Warning: incorrect row index %d bottom %f\n", rowIndex, m_rows[ rowIndex ].m_bottom );
		fprintf( stderr, "generated by module %d (%f,%f)\n", 
			curModuleId, 
			m_placedb.m_modules[ curModuleId ].m_x,
			m_placedb.m_modules[ curModuleId ].m_y );
		rowIndex--;
		break;
	    }
	}

	//rowIndex = max( 0, rowIndex );
	//rowIndex = min( static_cast<int>( m_rows.size() - 1 ), rowIndex );

	m_rows[ rowIndex ].m_module_queue.PushRight( curModuleId );
	
	//test code
	//fprintf( stdout, "Add module %s in row %d\n", m_placedb.m_modules[ curModuleId ].m_name.c_str(), rowIndex );
	//@test code
    }
}

CCellSlidingForCongestion::~CCellSlidingForCongestion( void )
{
}

void CCellSlidingForCongestion::Solve( const double& congThreshold, const SolveType& type )
{
    int gridNum = static_cast<int>( sqrt( static_cast<double>(m_placedb.m_modules.size()) ) * 0.8 );
    
    //test code
    //SlideOneRow( /*bounds,*/ m_rows[34], congThreshold );
    //@test code
    
    //Slide cells for each row
    for( unsigned int i = 0 ; i < m_rows.size() ; i++ )
    {
	m_pCongMap = new CCongMap( gridNum, gridNum, m_placedb.m_coreRgn, m_placedb.m_pLEF );
	CGlobalRouting groute( m_placedb );
	groute.ProbalisticMethod( *m_pCongMap );

	if( type == CMP )
	{
	    m_pGRouteMap = new GRouteMap( &m_placedb );
	    m_pGRouteMap->LoadCongMap( m_pCongMap );
	    m_pGRouteMap->OutputGnuplotFigure( "sliding_cmp" );
	}

	SlideOneRow( /*bounds,*/ m_rows[i], congThreshold, type );
    
	delete m_pCongMap;
	m_pCongMap = NULL;

	if( type == CMP )
	{
	    delete m_pGRouteMap;
	    m_pGRouteMap = NULL;
	}
    }
    

}

void CCellSlidingForCongestion::SlideOneRow( 
	//const std::vector<double>& bounds, 
	CCellSlidingRow& row, 
	const double& congThreshold,
        const SolveType& type )
{
    double row_center_y = row.m_bottom + row.m_height / 2.0;
    int vbin_index = m_pCongMap->GetVBinIndex( row_center_y );

    //Create bounds
    //the left/right bounds of ith bin are bounds[i]/bound[i+1]
    int row_start_index = m_pCongMap->GetHBinIndex( row.m_interval.front() );
    int row_end_index = m_pCongMap->GetHBinIndex( row.m_interval.back() );

    if( row_start_index == row_end_index )
    {
	return;
    }

    //# of bins crossed bin this row
    int row_bin_dim = row_end_index - row_start_index + 1;
    
    vector<double> bounds;
    bounds.reserve( row_bin_dim );
    bounds.push_back( row.m_interval.front() );
    for( int i = 0 ; i < row_bin_dim - 1 ; i++ )
    {
    	double bound_position = m_pCongMap->ComputeBinBBox( row_start_index + i, 0 ).right;
	bounds.push_back( bound_position );
    }
    bounds.push_back( row.m_interval.back() );
    //Make the bounds fit the step
    for( unsigned int i = 1 ; i < bounds.size() ; i++ )
    {
	bounds[i] = CutDownToStep( bounds[i] - bounds.front() ) + bounds.front();
    }
    
#if 0
    //test code
    fprintf( stdout, "bounds: " );
    for( unsigned int i = 0 ; i < bounds.size() ; i++ )
    {
	fprintf( stdout, "%f ", bounds[i] );
    }
    fprintf( stdout, "\n" );
    fflush( stdout );
    //@test code
#endif
    
    //Compute the congestion ratio of each bin
    //TODO: Consider only congestoin within bounds
    vector<double> congestion_ratios;
    double total_congestion = 0.0;
    congestion_ratios.reserve( row_bin_dim );

    for( int i = 0 ; i < row_bin_dim ; i++ )
    {
	if( type == CMP )
	{
	    congestion_ratios.push_back( m_pGRouteMap->GetBinWireDensity( row_start_index + i, vbin_index ) );
	}
	else
	{
	    congestion_ratios.push_back( m_pCongMap->GetBinOverflow( row_start_index + i, vbin_index ) );
	}

	//test code
	//fprintf( stdout, "congestion_ratios[%d]: %f\n", i, congestion_ratios[i] );
	//@test code
    }
    
    for( int i = 0 ; i < row_bin_dim ; i++ )
    {
	//Cut off congestions < congThreshold
	congestion_ratios[i] -= congThreshold;
	congestion_ratios[i] = max( 0.0, congestion_ratios[i] );

	total_congestion += congestion_ratios[i];
    }
    
    //test code
    //fprintf( stdout, "total_congestion: %f\n", total_congestion );
    //@test code
    
    if( total_congestion <= 0.0 )
    {
	return;
    }
    
    for( int i = 0 ; i < row_bin_dim ; i++ )
    {
	congestion_ratios[i] = congestion_ratios[i] / total_congestion;
	//test code
	//fprintf( stdout, "congestion_ratios[%d]: %f\n", i, congestion_ratios[i] );
	//@test code
    }

    //Compute the corresponding free widths (white spaces in terms of width) for each bin
    vector<double> free_widths;
    free_widths.reserve( row_bin_dim );
    
    double total_module_width = 0.0;
    for( list<int>::const_iterator ite = row.m_module_queue.Begin() ; 
	    ite != row.m_module_queue.End() ; ite++ )
    {
	const int moduleId = *ite;
	total_module_width += CutUpToStep( m_placedb.m_modules[ moduleId ].m_width );
    }

    double total_site_width = bounds.back() - bounds.front();
    double total_free_width = total_site_width - total_module_width;

#if 0
    //test code
    fprintf( stdout, "site left %f right %f\n", row.m_interval.front(), row.m_interval.back() );
    fprintf( stdout, "total_site_width %f\ntotal_module_width %f\ntotal_free_width %f\n",
	    total_site_width,
	    total_module_width,
	    total_free_width );
    fflush(stdout);
    //@test code
#endif
    
    if( total_free_width < 0.0 )
    {
	fprintf( stderr, "Error: incorrect free width %f\n", total_free_width );
	fflush(stderr);
	return;
    }

    for( int i = 0 ; i < row_bin_dim ; i++ )
    {
	free_widths[i] = total_free_width * congestion_ratios[i];
	//test code
	//fprintf( stdout, "free_widths[%d]: %f\n", i, free_widths[i] );
	//@test code
	
	free_widths[i] = CutDownToStep( free_widths[i] );

#if 0
	//test code
	fprintf( stdout, "free_widths[%d]: %f\n", i, free_widths[i] );
	fflush( stdout );
	//@test code
#endif
    }

    //Adjust free_widths to fit into the bin width
    //Strategy: allocated widths according to congestion
    //(take the step as the unit) 
    double used_free_width = 0.0;
    for( int i = 0 ; i < row_bin_dim ; i++ )
    {
	double bin_width = bounds[i+1] - bounds[i];
	if( free_widths[i] > bin_width )
	{
	    //remaining_width += free_widths[i] - bin_width;
	    free_widths[i] = bin_width;
	}
	used_free_width += free_widths[i];
    }
    double remaining_width = total_site_width - used_free_width - total_module_width;

    //Determine the bin congestion order
    //using pair< bin index, corresponding congestion >
    list< pair<int, double> > bin_congestion_list;
    for( int i = 0 ; i < row_bin_dim ; i++ )
    {
	if( type == CMP )
	{
	    bin_congestion_list.push_back( 
		    pair<int, double>( i, m_pGRouteMap->GetBinWireDensity( row_start_index + i, vbin_index ) ) );
	}
	else
	{
	    bin_congestion_list.push_back( 
		    pair<int, double>( i, m_pCongMap->GetBinOverflow( row_start_index + i, vbin_index ) ) );
	}
    }
    bin_congestion_list.sort( BinCongestionComparator() );
    
    for( list< pair<int, double> >::iterator ite = bin_congestion_list.begin() ; 
	    ite != bin_congestion_list.end() && remaining_width >= m_step ; ite++ )
    {
	int bin_index = ite->first;

	//Allocate free width to the found bin
	double max_allowable_width = bounds[ bin_index+1 ] - bounds[ bin_index ] - free_widths[ bin_index ];
	double allocated_width = min( max_allowable_width, remaining_width );
	allocated_width = CutDownToStep( allocated_width );
	free_widths[ bin_index ] += allocated_width;
	remaining_width -= allocated_width;
#if 0
	//test code
	fprintf( stdout, "remaining_width: %f\n", remaining_width );
	//@test code
#endif
    }
#if 0
    //Allocation remaining width to the most congested bin
    while( remaining_width >= m_step )
    {
	//Find the bin with maximum assigned free width and the width must < bin_width
	int max_index = -1;
	double max_width = -numeric_limits<double>::max();
	for( int i = 0 ; i < row_bin_dim ; i++ )
	{
	    double bin_width = bounds[i+1] - bounds[i];
	    if( free_widths[i] < bin_width &&
		    free_widths[i] > max_width )
	    {
		max_index = i;
		max_width = free_widths[i];
	    }
	}

	if( max_index == -1 )
	{
	    fprintf( stderr, "Error: cannot find any bins to allocate free space\n" );
	    fflush(stderr);
	    return;
	}

	//Allocate free width to the found bin
	double max_allowable_width = bounds[ max_index+1 ] - bounds[ max_index ] - free_widths[ max_index ];
	double allocated_width = min( max_allowable_width, remaining_width );
	allocated_width = CutDownToStep( allocated_width );
	free_widths[ max_index ] += allocated_width;
	remaining_width -= allocated_width;

	//test code
	fprintf( stdout, "remaining_width: %f\n", remaining_width );
	//@test code
    }
#endif
#if 0
    //test code
    for( int i = 0 ; i < row_bin_dim ; i++ )
    {
	//test code
	fprintf( stdout, "adjusted free_widths[%d]: %f\n", i, free_widths[i] );
	fflush( stdout );
	//@test code
    }
#endif
    //@test code

    //Place all cells to the correct position
    //The current horizontal bin index
    int current_hbin_index = 0;
    //The starting x coordinate
    double current_xcoor = bounds[0] + free_widths[0];

#if 0
    //test code
    fprintf( stdout, "start slide cells\n" );
    fflush(stdout);
    double test_module_width = 0.0;
    double test_free_width = free_widths[0];
    //@test code
#endif

    for( list<int>::const_iterator ite = row.m_module_queue.Begin() ; 
	    ite != row.m_module_queue.End() ; ite++ )
    {
	//current x coordinate already exceeds the right boundary of current bin
	//move x coordinate to next bin
	if( current_xcoor >= bounds[ current_hbin_index + 1 ] )
	{
	    current_hbin_index++;
	    current_xcoor += free_widths[ current_hbin_index ];
	    ite--;

#if 0
	    //test code
	    test_free_width += free_widths[ current_hbin_index ];
	    //@test code
#endif
	}
	else
	{
	    const int moduleId = *ite;
	    m_placedb.SetModuleLocation( moduleId, current_xcoor, row.m_bottom );
#if 0
	    //test code
	    fprintf( stdout, "place cell %s (%d) at (%f,%f) width %f\n", 
		    m_placedb.m_modules[ moduleId ].m_name.c_str(), moduleId, current_xcoor, row.m_bottom,
		    CutUpToStep( m_placedb.m_modules[ moduleId ].m_width ) );
	    test_module_width += CutUpToStep( m_placedb.m_modules[ moduleId ].m_width );
	    fflush(stdout);
	    //@test code
#endif
	    current_xcoor += CutUpToStep( m_placedb.m_modules[ moduleId ].m_width );
	}
    }
   
#if 0 
    //test code
    fprintf( stdout, "test_module_width %f\ntest_free_width %f\n", test_module_width, test_free_width );
    fflush( stdout );
    //@test code
#endif
}

